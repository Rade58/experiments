# Payload CMS Hooks: Complete Guide with Real-World Examples

Payload CMS provides a powerful hook system that lets you execute custom logic at specific points in the application lifecycle. Let me explain each hook with practical examples.

## **Collection Hooks**

### 1. **beforeOperation**
Runs before any operation (create, read, update, delete) on a collection.

**Real-world example:** Logging all database operations for audit trails
```javascript
{
  hooks: {
    beforeOperation: [
      async ({ args, operation }) => {
        console.log(`About to perform ${operation} operation`);
        // Log to external monitoring service
        await logToDatadog({
          operation,
          collection: 'products',
          timestamp: new Date()
        });
        return args;
      }
    ]
  }
}
```

### 2. **afterOperation**
Runs after any operation completes.

**Real-world example:** Clearing cache after data changes
```javascript
{
  hooks: {
    afterOperation: [
      async ({ result, operation }) => {
        if (['create', 'update', 'delete'].includes(operation)) {
          await redis.del('products:cache');
        }
        return result;
      }
    ]
  }
}
```

### 3. **beforeValidate**
Runs before Payload validates the incoming data.

**Real-world example:** Sanitizing user input before validation
```javascript
{
  hooks: {
    beforeValidate: [
      ({ data }) => {
        if (data.email) {
          data.email = data.email.toLowerCase().trim();
        }
        if (data.phoneNumber) {
          data.phoneNumber = data.phoneNumber.replace(/\D/g, '');
        }
        return data;
      }
    ]
  }
}
```

### 4. **beforeChange**
Runs before a document is created or updated, after validation.

**Real-world example:** Auto-generating slugs from titles
```javascript
{
  hooks: {
    beforeChange: [
      ({ data, operation }) => {
        if (operation === 'create' || !data.slug) {
          data.slug = data.title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-|-$/g, '');
        }
        return data;
      }
    ]
  }
}
```

### 5. **afterChange**
Runs after a document is created or updated.

**Real-world example:** Sending welcome email when user registers
```javascript
{
  hooks: {
    afterChange: [
      async ({ doc, operation, req }) => {
        if (operation === 'create') {
          await sendEmail({
            to: doc.email,
            subject: 'Welcome to our platform!',
            template: 'welcome',
            data: { name: doc.name }
          });
        }
        return doc;
      }
    ]
  }
}
```

### 6. **beforeRead**
Runs before documents are read/queried.

**Real-world example:** Restricting query results based on user role
```javascript
{
  hooks: {
    beforeRead: [
      ({ req, query }) => {
        // Non-admin users can only see published posts
        if (!req.user?.roles?.includes('admin')) {
          query.where = {
            ...query.where,
            status: { equals: 'published' }
          };
        }
        return query;
      }
    ]
  }
}
```

### 7. **afterRead**
Runs after documents are retrieved.

**Real-world example:** Masking sensitive data based on permissions
```javascript
{
  hooks: {
    afterRead: [
      ({ doc, req }) => {
        // Hide email from non-admin users
        if (!req.user?.roles?.includes('admin')) {
          delete doc.email;
          delete doc.phoneNumber;
        }
        return doc;
      }
    ]
  }
}
```

### 8. **beforeDelete**
Runs before a document is deleted.

**Real-world example:** Preventing deletion of critical records
```javascript
{
  hooks: {
    beforeDelete: [
      async ({ req, id }) => {
        const doc = await req.payload.findByID({
          collection: 'products',
          id
        });
        
        if (doc.isSystemProduct) {
          throw new Error('Cannot delete system products');
        }
      }
    ]
  }
}
```

### 9. **afterDelete**
Runs after a document is deleted.

**Real-world example:** Cleaning up related files and data
```javascript
{
  hooks: {
    afterDelete: [
      async ({ doc, req }) => {
        // Delete associated images from cloud storage
        if (doc.images?.length) {
          await Promise.all(
            doc.images.map(img => cloudStorage.delete(img.url))
          );
        }
        
        // Remove from search index
        await algolia.deleteObject(doc.id);
      }
    ]
  }
}
```

## **Field Hooks**

### 10. **beforeValidate** (Field-level)
Runs before a specific field is validated.

**Real-world example:** Converting price to cents for storage
```javascript
{
  name: 'price',
  type: 'number',
  hooks: {
    beforeValidate: [
      ({ value }) => {
        // Convert dollars to cents
        return Math.round(value * 100);
      }
    ]
  }
}
```

### 11. **afterRead** (Field-level)
Runs after a field value is read.

**Real-world example:** Formatting dates for display
```javascript
{
  name: 'createdAt',
  type: 'date',
  hooks: {
    afterRead: [
      ({ value }) => {
        return new Date(value).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
    ]
  }
}
```

## **Auth Hooks**

### 12. **afterLogin**
Runs after successful login.

**Real-world example:** Tracking user login analytics
```javascript
{
  hooks: {
    afterLogin: [
      async ({ user, req }) => {
        await req.payload.create({
          collection: 'login-logs',
          data: {
            user: user.id,
            ip: req.ip,
            userAgent: req.headers['user-agent'],
            timestamp: new Date()
          }
        });
      }
    ]
  }
}
```

### 13. **afterLogout**
Runs after user logs out.

**Real-world example:** Invalidating external sessions
```javascript
{
  hooks: {
    afterLogout: [
      async ({ req }) => {
        // Invalidate session in Redis
        await redis.del(`session:${req.user.id}`);
      }
    ]
  }
}
```

### 14. **afterRefresh**
Runs after token refresh.

**Real-world example:** Updating last active timestamp
```javascript
{
  hooks: {
    afterRefresh: [
      async ({ user, req }) => {
        await req.payload.update({
          collection: 'users',
          id: user.id,
          data: { lastActive: new Date() }
        });
      }
    ]
  }
}
```

### 15. **afterForgotPassword**
Runs after forgot password request.

**Real-world example:** Sending custom password reset email
```javascript
{
  hooks: {
    afterForgotPassword: [
      async ({ args, user }) => {
        const resetToken = args.token;
        await sendEmail({
          to: user.email,
          subject: 'Reset Your Password',
          html: `Click here to reset: ${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`
        });
      }
    ]
  }
}
```

## **Global Hooks**

### 16. **beforeValidate** (Global)
Runs before any global is validated.

**Real-world example:** Site settings validation
```javascript
// In a 'site-settings' global
{
  hooks: {
    beforeValidate: [
      ({ data }) => {
        if (data.maintenanceMode && !data.maintenanceMessage) {
          data.maintenanceMessage = 'Site under maintenance';
        }
        return data;
      }
    ]
  }
}
```

### 17. **beforeChange** (Global)
Runs before global data is updated.

**Real-world example:** Version control for site settings
```javascript
{
  hooks: {
    beforeChange: [
      async ({ data, req }) => {
        // Save previous version to history
        const current = await req.payload.findGlobal({
          slug: 'site-settings'
        });
        
        await req.payload.create({
          collection: 'settings-history',
          data: {
            settings: current,
            changedBy: req.user.id,
            changedAt: new Date()
          }
        });
        
        return data;
      }
    ]
  }
}
```

### 18. **afterChange** (Global)
Runs after global data is updated.

**Real-world example:** Triggering site rebuild on setting changes
```javascript
{
  hooks: {
    afterChange: [
      async ({ doc }) => {
        // Trigger Vercel/Netlify rebuild
        await fetch(process.env.BUILD_HOOK_URL, {
          method: 'POST'
        });
        
        // Clear CDN cache
        await cloudflare.purgeCache();
      }
    ]
  }
}
```

### 19. **afterRead** (Global)
Runs after global data is retrieved.

**Real-world example:** Injecting computed values
```javascript
{
  hooks: {
    afterRead: [
      ({ doc }) => {
        doc.computed = {
          totalUsers: doc.statistics?.users || 0,
          lastUpdated: new Date().toISOString()
        };
        return doc;
      }
    ]
  }
}
```

## **Advanced Multi-Hook Example**

Here's a complete real-world example combining multiple hooks for an e-commerce product:

```javascript
{
  slug: 'products',
  fields: [
    { name: 'name', type: 'text', required: true },
    { name: 'slug', type: 'text', unique: true },
    { name: 'price', type: 'number', required: true },
    { name: 'inventory', type: 'number', required: true },
    { name: 'status', type: 'select', options: ['draft', 'active', 'archived'] }
  ],
  hooks: {
    // Generate slug before validation
    beforeValidate: [
      ({ data, operation }) => {
        if (operation === 'create' && !data.slug) {
          data.slug = data.name.toLowerCase().replace(/\s+/g, '-');
        }
        return data;
      }
    ],
    
    // Check inventory before saving
    beforeChange: [
      async ({ data, req, operation }) => {
        if (operation === 'update' && data.inventory < 0) {
          throw new Error('Inventory cannot be negative');
        }
        
        // Auto-archive if out of stock
        if (data.inventory === 0) {
          data.status = 'archived';
        }
        
        return data;
      }
    ],
    
    // Notify team and update search index after changes
    afterChange: [
      async ({ doc, operation, previousDoc }) => {
        // Update Algolia search index
        await algolia.saveObject({
          objectID: doc.id,
          name: doc.name,
          price: doc.price,
          status: doc.status
        });
        
        // Send low stock alert
        if (doc.inventory < 10 && previousDoc?.inventory >= 10) {
          await sendSlackNotification({
            channel: '#inventory-alerts',
            message: `Low stock alert: ${doc.name} (${doc.inventory} remaining)`
          });
        }
        
        return doc;
      }
    ],
    
    // Clean up after deletion
    afterDelete: [
      async ({ doc }) => {
        await algolia.deleteObject(doc.id);
        await cloudStorage.deleteFolder(`products/${doc.id}`);
      }
    ]
  }
}
```

These hooks give you tremendous flexibility to customize Payload's behavior without modifying core functionality. You can chain multiple hooks together, and they execute in the order they're defined.