Yes! Using Zod schemas is actually an **excellent** solution and considered a best practice. It gives you:

1. ✅ Runtime validation (TypeScript only checks at compile time)
2. ✅ Type inference (no manual typing needed)
3. ✅ Automatic error handling
4. ✅ Request validation for body, params, and query
5. ✅ Better API documentation potential

## Complete Zod-based Solution

```ts
// utils/validation.ts
import { z } from 'zod'
import type { Request, Response, NextFunction, RequestHandler } from 'express'
import type { Payload } from '../utils/auth/jwt'

export interface AuthenticatedRequest extends Request {
	user: Payload
}

// Validation middleware factory
export function validateRequest
	TBody extends z.ZodType,
	TParams extends z.ZodType = z.ZodType<any>,
	TQuery extends z.ZodType = z.ZodType<any>,
>(schema: {
	body?: TBody
	params?: TParams
	query?: TQuery
}) {
	return async (req: Request, res: Response, next: NextFunction) => {
		try {
			if (schema.body) {
				req.body = await schema.body.parseAsync(req.body)
			}
			if (schema.params) {
				req.params = await schema.params.parseAsync(req.params)
			}
			if (schema.query) {
				req.query = await schema.query.parseAsync(req.query)
			}
			next()
		} catch (error) {
			if (error instanceof z.ZodError) {
				return res.status(400).json({
					error: 'Validation failed',
					details: error.errors
				})
			}
			next(error)
		}
	}
}

// Typed handler for authenticated + validated routes
export type ValidatedAuthHandler
	TBody = any,
	TParams = any,
	TQuery = any,
> = (
	req: AuthenticatedRequest & {
		body: TBody
		params: TParams
		query: TQuery
	},
	res: Response
) => Promise<any> | any

export function authValidatedHandler
	TBody = any,
	TParams = any,
	TQuery = any,
>(
	handler: ValidatedAuthHandler<TBody, TParams, TQuery>
): RequestHandler {
	return handler as any
}
```

## Usage in Your Routes

```ts
// routes/habits.ts
import { z } from 'zod'
import { Router } from 'express'
import { authenticateToken } from '../middleware/auth'
import { validateRequest, authValidatedHandler } from '../utils/validation'
import type { AuthenticatedRequest } from '../utils/validation'

const router = Router()

// Apply auth middleware to all routes
router.use(authenticateToken)

// 1. GET /habits - List all habits
const getHabitsQuerySchema = z.object({
	limit: z.coerce.number().optional().default(10),
	offset: z.coerce.number().optional().default(0),
})

router.get(
	'/',
	validateRequest({ query: getHabitsQuerySchema }),
	authValidatedHandler
		{},
		{},
		z.infer<typeof getHabitsQuerySchema>
	>(async (req, res) => {
		const userId = req.user.id
		const { limit, offset } = req.query // Fully typed!
		
		const habits = await db.query.habits.findMany({
			where: eq(habits.userId, userId),
			limit,
			offset
		})
		
		return res.json(habits)
	})
)

// 2. POST /habits - Create habit
const createHabitSchema = z.object({
	name: z.string().min(1).max(100),
	description: z.string().max(500).optional(),
	frequency: z.enum(['daily', 'weekly', 'monthly']),
	targetCount: z.number().int().positive().optional(),
})

router.post(
	'/',
	validateRequest({ body: createHabitSchema }),
	authValidatedHandler<z.infer<typeof createHabitSchema>>(
		async (req, res) => {
			const userId = req.user.id
			const { name, description, frequency, targetCount } = req.body // Typed & validated!
			
			const [newHabit] = await db.insert(habits).values({
				userId,
				name,
				description,
				frequency,
				targetCount,
			}).returning()
			
			return res.status(201).json(newHabit)
		}
	)
)

// 3. GET /habits/:habitId - Get single habit
const habitParamsSchema = z.object({
	habitId: z.string().uuid(),
})

router.get(
	'/:habitId',
	validateRequest({ params: habitParamsSchema }),
	authValidatedHandler
		{},
		z.infer<typeof habitParamsSchema>
	>(async (req, res) => {
		const userId = req.user.id
		const { habitId } = req.params // Typed & validated!
		
		const habit = await db.query.habits.findFirst({
			where: and(
				eq(habits.id, habitId),
				eq(habits.userId, userId)
			)
		})
		
		if (!habit) {
			return res.status(404).json({ error: 'Habit not found' })
		}
		
		return res.json(habit)
	})
)

// 4. PATCH /habits/:habitId - Update habit
const updateHabitSchema = z.object({
	name: z.string().min(1).max(100).optional(),
	description: z.string().max(500).optional(),
	frequency: z.enum(['daily', 'weekly', 'monthly']).optional(),
	targetCount: z.number().int().positive().optional(),
})

router.patch(
	'/:habitId',
	validateRequest({
		params: habitParamsSchema,
		body: updateHabitSchema,
	}),
	authValidatedHandler
		z.infer<typeof updateHabitSchema>,
		z.infer<typeof habitParamsSchema>
	>(async (req, res) => {
		const userId = req.user.id
		const { habitId } = req.params
		const updates = req.body
		
		const [updatedHabit] = await db
			.update(habits)
			.set(updates)
			.where(and(
				eq(habits.id, habitId),
				eq(habits.userId, userId)
			))
			.returning()
		
		if (!updatedHabit) {
			return res.status(404).json({ error: 'Habit not found' })
		}
		
		return res.json(updatedHabit)
	})
)

export default router
```

## Even Cleaner: Using Drizzle-Zod

If you're using Drizzle, you can generate Zod schemas automatically:

```ts
// db/schema.ts
import { pgTable, uuid, text, timestamp } from 'drizzle-orm/pg-core'
import { createInsertSchema, createSelectSchema } from 'drizzle-zod'

export const habits = pgTable('habits', {
	id: uuid('id').defaultRandom().primaryKey(),
	userId: uuid('user_id').notNull(),
	name: text('name').notNull(),
	description: text('description'),
	createdAt: timestamp('created_at').defaultNow().notNull(),
})

// Auto-generated schemas!
export const insertHabitSchema = createInsertSchema(habits).omit({
	id: true,
	userId: true,
	createdAt: true,
})

export const selectHabitSchema = createSelectSchema(habits)

// Customize if needed
export const createHabitSchema = insertHabitSchema.extend({
	name: z.string().min(1).max(100),
})
```

Then use directly:

```ts
import { createHabitSchema } from '../db/schema'

router.post(
	'/',
	validateRequest({ body: createHabitSchema }),
	authValidatedHandler<z.infer<typeof createHabitSchema>>(
		async (req, res) => {
			// req.body is fully typed and validated!
		}
	)
)
```

## Benefits Over Manual Typing

| Approach     | Runtime Safety | Type Safety | Boilerplate | Error Messages |
| ------------ | -------------- | ----------- | ----------- | -------------- |
| Manual types | ❌ No           | ✅ Yes       | Medium      | Generic        |
| Zod schemas  | ✅ Yes          | ✅ Yes       | Low         | Detailed       |
| Drizzle-Zod  | ✅ Yes          | ✅ Yes       | Very Low    | Detailed       |

**My recommendation**: Use Zod schemas with the validation middleware. It's the industry standard for TypeScript APIs and gives you both compile-time and runtime safety. If you're using Drizzle, definitely use `drizzle-zod` to auto-generate your schemas!